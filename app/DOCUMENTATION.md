# SnoozeSpot Android Application - Complete Documentation

---

## Table of Contents

1. [Project Overview](#project-overview)
2. [Architecture & Design](#architecture--design)
3. [Key Features](#key-features)
4. [Technology Stack](#technology-stack)
5. [Project Structure](#project-structure)
6. [Setup & Installation](#setup--installation)
7. [Build & Deployment](#build--deployment)
8. [API Integration](#api-integration)
9. [Database Schema](#database-schema)
10. [Development Guidelines](#development-guidelines)
11. [Contributing Guidelines](#contributing-guidelines)
12. [Troubleshooting](#troubleshooting)

---

## Project Overview

### What is SnoozeSpot?

SnoozeSpot is a mobile-first Android application designed to help users discover, share, and manage safe resting spots. The application leverages location services and community-driven content to provide a comprehensive solution for travelers, commuters, and anyone in need of finding safe places to rest.

### Target Audience

- Travelers and backpackers seeking accommodation recommendations
- Commuters looking for rest areas during long journeys
- Urban explorers discovering new locations
- Community contributors sharing safe resting spots

### Current Status

- **Version**: 1.0
- **Minimum SDK**: Android 7.0 (API 24)
- **Target SDK**: Android 15 (API 36)
- **Java/Kotlin Version**: Java 11, Kotlin 2.2.20
- **Current Environment**: Under active development with three build flavors (development, beta, production)

### Core Capabilities

- **Location Mapping**: Integration with Google Maps to display and explore rest spots globally
- **Post Management**: Create, edit, and delete posts about discovered spots
- **Comments & Discussion**: Community engagement through comments on posts
- **User Authentication**: Secure user registration and login
- **Multi-environment Support**: Development, beta, and production builds with separate configurations
- **Local Data Persistence**: Room database for offline-first functionality
- **User Preferences**: DataStore integration for lightweight preference management

---

## Architecture & Design

### Architectural Pattern: MVVM + Repository

SnoozeSpot follows the **Model-View-ViewModel** (MVVM) architecture combined with the **Repository Pattern** to ensure separation of concerns, testability, and maintainability.

```
UI Layer (Jetpack Compose)
    ↓
ViewModel Layer
    ↓
Repository Layer
    ↓
Data Layer (Room, DataStore, API)
```

### Layer Descriptions

#### 1. **UI Layer - Jetpack Compose**
- Modern declarative UI framework
- Composable functions for screen layouts
- State management through ViewModels
- Located in: `src/main/java/iut/fauryollivier/snoozespot/ui/`

#### 2. **ViewModel Layer**
- Manages UI state and business logic
- Survives configuration changes
- Communicates with repositories
- Handles user interactions

#### 3. **Repository Layer**
- Abstract data sources (API, local database)
- Implements Repository Pattern for clean API
- Handles data synchronization logic
- Located in: `src/main/java/iut/fauryollivier/snoozespot/repositories/`

#### 4. **Data Layer**
Composed of multiple data sources:

- **Network Data Source** (`api/`): REST API client generated by OpenAPI Generator
- **Local Database** (`room/`): Room persistence layer with Entities, DAOs, and TypeConverters
- **Preferences** (`datastore/`): DataStore for lightweight user preferences

### Design Principles

1. **Separation of Concerns**: Each layer has distinct responsibilities
2. **Single Responsibility Principle**: Each class/function does one thing well
3. **Dependency Injection**: Loose coupling between components
4. **Reactive Programming**: Flow-based data streams for real-time updates
5. **Error Handling**: Graceful error recovery and user feedback

---

## Key Features

### 1. Spot Discovery & Mapping
- **Google Maps Integration**: Display all rest spots on an interactive map
- **Real-time Location Tracking**: Show user's current location
- **Spot Details**: Comprehensive information about each spot (location, amenities, ratings)
- **Search & Filtering**: Find spots by category, distance, or rating

### 2. Post Management
- **Create Posts**: Users can submit new rest spot discoveries
- **Edit Posts**: Modify existing post information
- **Delete Posts**: Remove posts (with appropriate permissions)
- **Rich Content**: Support for images, descriptions, and metadata

### 3. User Engagement
- **Comments**: Discuss spots with other users
- **Ratings & Reviews**: Rate spots on safety, cleanliness, comfort
- **Community Feedback**: Upvote/downvote system (if applicable)

### 4. User Management
- **Authentication**: Secure login and registration
- **User Profiles**: Personal information and activity history
- **Preferences**: Save favorite spots and customize experience

### 5. Multi-environment Deployment
- **Development Flavor**: For internal testing with dev API endpoint
- **Beta Flavor**: For external testing with beta API endpoint
- **Production Flavor**: Official release with production API endpoint
- Each flavor maintains separate API keys and configurations

### 6. Offline-First Capability
- **Local Caching**: Room database stores downloaded spots and user posts
- **Sync on Reconnection**: Automatically synchronizes local changes when connection is restored
- **Conflict Resolution**: Handles data conflicts between local and server versions

---

## Technology Stack

### Core Framework & UI
| Technology | Version | Purpose |
|------------|---------|---------|
| **Kotlin** | 2.2.20 | Primary programming language |
| **Jetpack Compose** | 2024.09.00 | Declarative UI framework |
| **Compose Destinations** | 1.10.2 | Navigation between screens |
| **Material 3** | Latest | UI design system and components |
| **Coil Compose** | 3.3.0 | Image loading and caching |

### Architecture & Data
| Technology | Version | Purpose |
|------------|---------|---------|
| **Room Database** | 2.8.4 | Local SQLite persistence |
| **DataStore** | 1.2.0 | Lightweight preferences storage |
| **Kotlin Coroutines** | Integrated | Asynchronous programming |
| **Flow** | Integrated | Reactive data streams |

### Network & API
| Technology | Version | Purpose |
|------------|---------|---------|
| **Retrofit** | 2.9.0 / 3.0.0 | HTTP client framework |
| **OkHttp** | 5.1.0 | HTTP interceptor and client |
| **Moshi** | 1.15.2 | JSON serialization |
| **Kotlinx Serialization** | 1.9.0 | Kotlin-native serialization |
| **OpenAPI Generator** | 7.16.0 | API client code generation |
| **Logging Interceptor** | 5.1.0 | HTTP request/response logging |

### Location & Maps
| Technology | Version | Purpose |
|------------|---------|---------|
| **Google Maps Compose** | 6.12.1 | Interactive map UI component |
| **Location Services** | Android SDK | User location retrieval |

### Testing
| Technology | Version | Purpose |
|------------|---------|---------|
| **JUnit 4** | 4.13.2 | Unit testing framework |
| **JUnit 5** | 3.4.2 | Advanced testing features |
| **Espresso** | 3.7.0 | UI testing framework |

### Build & Development
| Technology | Version | Purpose |
|------------|---------|---------|
| **Gradle** | 8.11.1 (AGP) | Build automation |
| **Gradle Secrets Plugin** | 2.0.1 | Secure API key management |
| **ProGuard** | Built-in | Code obfuscation |
| **KSP** | 2.2.20-2.0.3 | Kotlin Symbol Processing (annotation processing) |

### Android Framework
| Technology | Version | Purpose |
|------------|---------|---------|
| **AndroidX Core** | 1.17.0 | Modern Android API compatibility |
| **AndroidX Lifecycle** | 2.9.3-2.9.4 | Lifecycle-aware components |
| **AndroidX Activity** | 1.11.0 | Activity integration with Compose |

---

## Project Structure

```
SnoozeSpot/
├── app/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/iut/fauryollivier/snoozespot/
│   │   │   │   ├── api/                    # OpenAPI generated + NetworkDataSource
│   │   │   │   │   ├── generated/          # OpenAPI generator output (auto-generated)
│   │   │   │   │   └── NetworkDataSource.kt # Custom network data layer
│   │   │   │   │
│   │   │   │   ├── app/                    # Application class & global config
│   │   │   │   │
│   │   │   │   ├── datastore/              # DataStore preferences
│   │   │   │   │   ├── UserPreferences.kt
│   │   │   │   │   └── PreferencesRepository.kt
│   │   │   │   │
│   │   │   │   ├── repositories/           # Repository implementation
│   │   │   │   │   ├── SpotRepository.kt
│   │   │   │   │   ├── UserRepository.kt
│   │   │   │   │   └── CommentRepository.kt
│   │   │   │   │
│   │   │   │   ├── room/                   # Room database layer
│   │   │   │   │   ├── db/                 # Database class & migrations
│   │   │   │   │   │   ├── AppDatabase.kt
│   │   │   │   │   │   └── migrations/
│   │   │   │   │   ├── entity/             # Room entities (@Entity)
│   │   │   │   │   │   ├── SpotEntity.kt
│   │   │   │   │   │   ├── PostEntity.kt
│   │   │   │   │   │   └── CommentEntity.kt
│   │   │   │   │   ├── dao/                # Data Access Objects
│   │   │   │   │   │   ├── SpotDao.kt
│   │   │   │   │   │   ├── PostDao.kt
│   │   │   │   │   │   └── CommentDao.kt
│   │   │   │   │   └── converter/          # Type converters
│   │   │   │   │       └── RoomJsonConverters.kt
│   │   │   │   │
│   │   │   │   ├── ui/                     # Jetpack Compose screens
│   │   │   │   │   ├── screens/            # Full-screen composables
│   │   │   │   │   │   ├── MapScreen.kt
│   │   │   │   │   │   ├── DetailScreen.kt
│   │   │   │   │   │   ├── CreatePostScreen.kt
│   │   │   │   │   │   └── AuthScreen.kt
│   │   │   │   │   ├── components/         # Reusable UI components
│   │   │   │   │   │   ├── SpotCard.kt
│   │   │   │   │   │   ├── CommentItem.kt
│   │   │   │   │   │   └── RatingBar.kt
│   │   │   │   │   ├── viewmodel/          # ViewModels for screens
│   │   │   │   │   │   ├── MapViewModel.kt
│   │   │   │   │   │   └── DetailViewModel.kt
│   │   │   │   │   └── navigation/         # Navigation setup
│   │   │   │   │       └── NavGraph.kt
│   │   │   │   │
│   │   │   │   ├── utils/                  # Utility functions
│   │   │   │   │   ├── Constants.kt
│   │   │   │   │   ├── Extensions.kt
│   │   │   │   │   └── Validators.kt
│   │   │   │   │
│   │   │   │   └── MainActivity.kt         # Application entry point
│   │   │   │
│   │   │   └── res/                        # Resources
│   │   │       ├── drawable/               # Images and vectors
│   │   │       ├── values/                 # Strings, colors, dimens
│   │   │       ├── xml/                    # Network security config
│   │   │       └── layout/                 # XML layouts (if any)
│   │   │
│   │   ├── androidTest/                    # Instrumented tests
│   │   ├── test/                           # Unit tests
│   │   └── beta/                           # Beta flavor-specific resources
│   │
│   ├── build.gradle.kts                    # App-level Gradle configuration
│   └── proguard-rules.pro                  # ProGuard obfuscation rules
│
├── gradle/
│   └── libs.versions.toml                  # Centralized dependency versioning
│
├── build.gradle.kts                        # Root Gradle configuration
├── settings.gradle.kts                     # Project structure definition
├── gradle.properties                       # Gradle system properties
├── secrets.properties                      # API keys and secrets (git-ignored)
├── local.properties                        # Local development config
└── doc.md                                  # This documentation file
```

### Key Directories Explained

**`api/`** - Network communication layer
- Contains OpenAPI-generated Retrofit service definitions
- Custom NetworkDataSource implementations for high-level API calls
- Error handling and response transformation

**`repositories/`** - Business logic & data orchestration
- Abstracts data sources (API, local database)
- Implements caching and sync logic
- Handles complex data operations

**`room/`** - Local persistence layer
- **entity/**: Database table definitions
- **dao/**: SQL query methods
- **converter/**: Custom type conversions for complex objects
- **db/**: Database setup and migrations

**`datastore/`** - User preferences
- Lightweight key-value storage
- Non-sensitive user settings and preferences

**`ui/`** - User interface layer
- **screens/**: Full-screen Composables representing app pages
- **components/**: Reusable UI building blocks
- **viewmodel/**: State management per screen
- **navigation/**: Screen navigation graph

**`utils/`** - Shared utilities
- Constants, extension functions
- Validation and formatting helpers

---

## Setup & Installation

### Prerequisites

Before setting up SnoozeSpot, ensure you have the following installed:

1. **Android Studio**: Latest stable version (Koala or newer)
2. **Android SDK**: 
   - Minimum SDK API 24 (Android 7.0)
   - Target SDK API 36 (Android 15)
3. **Java Development Kit**: Java 11 or later
4. **Git**: For cloning the repository
5. **Gradle**: 8.11.1 or compatible version

### Step 1: Clone the Repository

```bash
git clone <repository-url>
cd SnoozeSpot2
```

### Step 2: Install SDK Components

Open Android Studio and ensure the following SDK components are installed:
- Android SDK Platform 36 (or later)
- Android SDK Build Tools 36.x
- Google APIs or Google Play Services add-ons
- Android Emulator

### Step 3: Configure Gradle Properties

Edit `gradle.properties` and configure JVM memory:
```properties
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
```

### Step 4: Set Up API Keys

Create a `secrets.properties` file in the project root:

```properties
# Google Maps API Key
MAPS_API_KEY=your_google_maps_api_key_here

# API Server Endpoints (example)
API_BASE_URL_DEV=https://dev-api.snoozespot.local
API_BASE_URL_BETA=https://beta-api.snoozespot.com
API_BASE_URL_PROD=https://api.snoozespot.com
```

**Important**: Never commit `secrets.properties` to version control. Add it to `.gitignore`.

### Step 5: OpenAPI Generator Configuration

The project uses OpenAPI Generator to create API client code. Ensure you have:
1. OpenAPI specification file (e.g., `openapi.yaml` or `openapi.json`)
2. Generator configuration in `build.gradle.kts`

### Step 6: Build the Project

```bash
# Sync Gradle (in Android Studio or terminal)
./gradlew clean build

# Or use Android Studio's "Sync Now" button
```

### Step 7: Run the App

**Using Android Studio:**
1. Select desired build flavor (development, beta, production) from Build Variants
2. Run → Run 'app' (or press Shift+F10)

**Using Command Line:**
```bash
./gradlew installDevelopmentDebug     # Install development build
./gradlew installBetaDebug            # Install beta build
./gradlew installProductionDebug      # Install production build
```

---

## Build & Deployment

### Build System Overview

SnoozeSpot uses **Gradle** with **Kotlin DSL** for build automation. The build system supports multiple flavors and build types for different deployment scenarios.

### Build Flavors

The project defines three product flavors, each targeting a different environment:

#### 1. Development Flavor
- **Application ID**: `iut.fauryollivier.snoozespot.dev`
- **Version Suffix**: `-dev`
- **API Endpoint**: Development/staging server
- **API Key**: Development API key (buildConfigField: `clefDev`)
- **Use Case**: Internal testing and development
- **Command**: `./gradlew installDevelopmentDebug`

#### 2. Beta Flavor
- **Application ID**: `iut.fauryollivier.snoozespot.beta`
- **Version Suffix**: `-beta`
- **API Endpoint**: Beta server for external testing
- **API Key**: Beta API key (buildConfigField: `clefBeta`)
- **Use Case**: User acceptance testing (UAT) and external feedback
- **Command**: `./gradlew installBetaDebug`

#### 3. Production Flavor
- **Application ID**: `iut.fauryollivier.snoozespot`
- **Version Name**: No suffix (official version)
- **API Endpoint**: Production server
- **API Key**: Production API key (buildConfigField: `clefProd`)
- **Use Case**: Official release to Google Play Store
- **Command**: `./gradlew installProductionDebug`

### Build Types

| Build Type | Optimization | Debugging | Use Case |
|-----------|--------------|-----------|----------|
| **Debug** | Minimal | Full symbols | Development & testing |
| **Release** | ProGuard enabled | Symbols removed | Production distribution |

### Building for Release

```bash
# Production release build
./gradlew assembleProductionRelease

# Creates: app/build/outputs/apk/production/release/app-production-release.apk

# Create Android App Bundle (for Google Play Store)
./gradlew bundleProductionRelease

# Creates: app/build/outputs/bundle/productionRelease/app-production-release.aab
```

### OpenAPI Client Code Generation

The build process automatically generates Retrofit API client code from OpenAPI specifications:

```bash
# Triggered during build process
./gradlew generateOpenApiClient

# Generates code in: app/build/generated/openapi/
```

**Configuration in `build.gradle.kts`:**
```kotlin
openApiGenerator {
    generatorName.set("kotlin")
    inputSpec.set("path/to/openapi.yaml")
    outputDir.set("$buildDir/generated/openapi/")
    packageName.set("iut.fauryollivier.snoozespot.api.generated")
}
```

### ProGuard/R8 Obfuscation

The release build applies obfuscation rules defined in `proguard-rules.pro`:

```proguard
# Example rules
-keep class iut.fauryollivier.snoozespot.** { *; }
-keepclassmembers class * extends android.content.Context { *; }
-dontnote **
```

### Signing Configuration

For production releases, configure signing in `build.gradle.kts`:

```kotlin
signingConfigs {
    create("release") {
        storeFile = file("path/to/keystore.jks")
        storePassword = System.getenv("KEYSTORE_PASSWORD")
        keyAlias = System.getenv("KEY_ALIAS")
        keyPassword = System.getenv("KEY_PASSWORD")
    }
}

buildTypes {
    release {
        signingConfig = signingConfigs.getByName("release")
    }
}
```

### Build Variants

The Gradle build system creates **9 build variants** (3 flavors × 3 build types):

```
developmentDebug, developmentRelease
betaDebug, betaRelease
productionDebug, productionRelease
```

Select variants in Android Studio via **Build → Select Build Variant**.

---

## API Integration

### Overview

SnoozeSpot communicates with a backend REST API for data persistence and user management. The API client is generated using **OpenAPI Generator** and consumed through the **Repository Pattern**.

### API Architecture

```
UI/ViewModel
    ↓
Repository (SpotRepository, UserRepository, etc.)
    ↓
NetworkDataSource
    ↓
OpenAPI-Generated Retrofit Service
    ↓
OkHttp Client (with interceptors)
    ↓
REST API Server
```

### OpenAPI Generator Workflow

1. **OpenAPI Specification**: Define API in YAML/JSON format
2. **Generate Client**: Gradle task generates Kotlin/Retrofit code
3. **Generated Artifacts**: 
   - Service interfaces with `@retrofit2.http.*` annotations
   - Model classes for requests/responses
   - API client factory classes
4. **Custom Wrapping**: Create NetworkDataSource classes for high-level operations

### Network Configuration

#### Base URL Configuration

```kotlin
// Configured per build flavor in build.gradle.kts
buildConfigField("String", "API_BASE_URL_DEV", "\"https://dev-api.example.com\"")
buildConfigField("String", "API_BASE_URL_PROD", "\"https://api.example.com\"")

// Used in Retrofit setup
val retrofit = Retrofit.Builder()
    .baseUrl(BuildConfig.API_BASE_URL_DEV)
    .addConverterFactory(JsonConverterFactory.create())
    .client(httpClient)
    .build()
```

#### HTTP Client Configuration

OkHttp with custom interceptors:

```kotlin
val httpClient = OkHttpClient.Builder()
    .addInterceptor(AuthenticationInterceptor())      // Add auth headers
    .addInterceptor(LoggingInterceptor())             // Log requests/responses
    .addInterceptor(ErrorHandlingInterceptor())       // Handle HTTP errors
    .connectTimeout(30, TimeUnit.SECONDS)
    .readTimeout(30, TimeUnit.SECONDS)
    .writeTimeout(30, TimeUnit.SECONDS)
    .build()
```

### Authentication

Implement authentication through interceptors:

```kotlin
class AuthenticationInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
            .newBuilder()
            .addHeader("Authorization", "Bearer $authToken")
            .build()
        return chain.proceed(request)
    }
}
```

### Response Handling

#### Success Response Example

```kotlin
// Repository method
suspend fun fetchSpots(): List<SpotDTO> {
    return try {
        apiService.getSpots()
    } catch (e: HttpException) {
        handleHttpError(e)
    } catch (e: IOException) {
        handleNetworkError(e)
    }
}

// Save to local database
suspend fun fetchAndCacheSpots() {
    val spots = fetchSpots()
    spotDao.insertSpots(spots.map { it.toRoomEntity() })
}
```

#### Error Handling

```kotlin
sealed class ApiResult<T> {
    data class Success<T>(val data: T) : ApiResult<T>()
    data class Error<T>(val exception: Exception) : ApiResult<T>()
    class Loading<T> : ApiResult<T>()
}

// Usage
Flow<ApiResult<List<Spot>>> = flow {
    emit(ApiResult.Loading())
    try {
        val data = apiService.getSpots()
        emit(ApiResult.Success(data))
    } catch (e: Exception) {
        emit(ApiResult.Error(e))
    }
}
```

### JSON Serialization

SnoozeSpot supports both **Moshi** and **Kotlinx Serialization**:

```kotlin
// Moshi (generated by OpenAPI)
@JsonClass(generateAdapter = true)
data class SpotDTO(
    @Json(name = "spot_id")
    val spotId: String,
    val name: String,
    val latitude: Double,
    val longitude: Double
)

// Kotlinx Serialization
@Serializable
data class PostDTO(
    @SerialName("post_id")
    val postId: String,
    val content: String,
    @SerialName("created_at")
    val createdAt: String
)
```

### Rate Limiting & Caching

Implement intelligent caching to reduce API calls:

```kotlin
// Room acts as cache
class SpotRepository(
    private val apiService: SpotApiService,
    private val spotDao: SpotDao
) {
    fun getSpots(): Flow<List<Spot>> = flow {
        // Emit cached data first
        emit(spotDao.getAllSpots().map { it.toDomain() })
        
        // Fetch fresh data
        try {
            val fresh = apiService.getSpots()
            spotDao.insertSpots(fresh.map { it.toRoomEntity() })
            emit(spotDao.getAllSpots().map { it.toDomain() })
        } catch (e: Exception) {
            // Keep using cached data
        }
    }
}
```

### Testing API Integration

```kotlin
// Mock API responses for testing
class MockApiService : SpotApiService {
    override suspend fun getSpots(): List<SpotDTO> {
        return listOf(
            SpotDTO("1", "Cozy Park", 48.8566, 2.3522),
            SpotDTO("2", "Quiet Library", 48.8566, 2.3525)
        )
    }
}
```

---

## Database Schema

### Overview

SnoozeSpot uses **Room Database** for local SQLite persistence, enabling offline functionality and efficient data caching.

### Database Architecture

```
AppDatabase (SQLite)
├── Spots Table
├── Posts Table
├── Comments Table
├── Users Table (optional)
└── Migrations (versioning)
```

### Entities

#### SpotEntity
Represents a geographical rest spot.

```kotlin
@Entity(tableName = "spots")
data class SpotEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val spotId: String,           // API server ID
    val name: String,
    val description: String,
    val latitude: Double,
    val longitude: Double,
    val category: String,         // "park", "library", "bench", etc.
    val amenities: String,        // JSON array (converted)
    val safetyRating: Float,
    val cleanlinessRating: Float,
    val comfortRating: Float,
    val createdAt: Long,          // Timestamp
    val updatedAt: Long,
    val isFavorite: Boolean = false,
    @ColumnInfo(name = "image_url")
    val imageUrl: String? = null
)
```

#### PostEntity
Represents a user post about a spot.

```kotlin
@Entity(
    tableName = "posts",
    foreignKeys = [
        ForeignKey(
            entity = SpotEntity::class,
            parentColumns = ["spotId"],
            childColumns = ["spotId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class PostEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val postId: String,           // API server ID
    val spotId: String,           // Reference to Spot
    val userId: String,
    val content: String,
    val imageUrls: String,        // JSON array (converted)
    val timestamp: Long,
    val upvotes: Int = 0,
    val downvotes: Int = 0,
    val isSynced: Boolean = false // Sync flag for offline posts
)
```

#### CommentEntity
Represents comments on posts.

```kotlin
@Entity(
    tableName = "comments",
    foreignKeys = [
        ForeignKey(
            entity = PostEntity::class,
            parentColumns = ["postId"],
            childColumns = ["postId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class CommentEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val commentId: String,
    val postId: String,
    val userId: String,
    val content: String,
    val timestamp: Long,
    val isSynced: Boolean = false
)
```

### Type Converters

Complex objects are converted to JSON strings for storage:

```kotlin
class RoomJsonConverters {
    @TypeConverter
    fun listToJson(list: List<String>?): String? {
        return list?.let { Gson().toJson(it) }
    }

    @TypeConverter
    fun jsonToList(json: String?): List<String>? {
        return json?.let { 
            Gson().fromJson(it, object : TypeToken<List<String>>() {}.type)
        }
    }

    @TypeConverter
    fun mapToJson(map: Map<String, Any>?): String? {
        return map?.let { Gson().toJson(it) }
    }

    @TypeConverter
    fun jsonToMap(json: String?): Map<String, Any>? {
        return json?.let {
            Gson().fromJson(it, object : TypeToken<Map<String, Any>>() {}.type)
        }
    }
}
```

### Data Access Objects (DAOs)

#### SpotDao

```kotlin
@Dao
interface SpotDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertSpots(spots: List<SpotEntity>)

    @Query("SELECT * FROM spots ORDER BY name ASC")
    fun getAllSpots(): Flow<List<SpotEntity>>

    @Query("SELECT * FROM spots WHERE id = :spotId")
    fun getSpotById(spotId: Long): Flow<SpotEntity>

    @Query("SELECT * FROM spots WHERE isFavorite = 1")
    fun getFavoriteSpots(): Flow<List<SpotEntity>>

    @Query("SELECT * FROM spots WHERE safetyRating >= :minRating")
    fun getSpotsByRating(minRating: Float): Flow<List<SpotEntity>>

    @Delete
    suspend fun deleteSpot(spot: SpotEntity)

    @Query("DELETE FROM spots WHERE spotId = :spotId")
    suspend fun deleteSpotById(spotId: String)
}
```

#### PostDao

```kotlin
@Dao
interface PostDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertPost(post: PostEntity)

    @Query("SELECT * FROM posts WHERE spotId = :spotId ORDER BY timestamp DESC")
    fun getPostsBySpot(spotId: String): Flow<List<PostEntity>>

    @Query("SELECT * FROM posts WHERE userId = :userId ORDER BY timestamp DESC")
    fun getPostsByUser(userId: String): Flow<List<PostEntity>>

    @Query("SELECT * FROM posts WHERE isSynced = 0")
    suspend fun getUnsyncedPosts(): List<PostEntity>

    @Update
    suspend fun updatePost(post: PostEntity)

    @Delete
    suspend fun deletePost(post: PostEntity)
}
```

#### CommentDao

```kotlin
@Dao
interface CommentDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertComment(comment: CommentEntity)

    @Query("SELECT * FROM comments WHERE postId = :postId ORDER BY timestamp DESC")
    fun getCommentsByPost(postId: String): Flow<List<CommentEntity>>

    @Query("SELECT * FROM comments WHERE isSynced = 0")
    suspend fun getUnsyncedComments(): List<CommentEntity>

    @Delete
    suspend fun deleteComment(comment: CommentEntity)
}
```

### Database Setup

```kotlin
@Database(
    entities = [
        SpotEntity::class,
        PostEntity::class,
        CommentEntity::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(RoomJsonConverters::class)
abstract class AppDatabase : RoomDatabase() {
    abstract fun spotDao(): SpotDao
    abstract fun postDao(): PostDao
    abstract fun commentDao(): CommentDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "snoozespot.db"
                )
                .addCallback(DatabaseCallback())
                .build()
                .also { INSTANCE = it }
            }
        }
    }
}
```

### Database Migrations

When schema changes, create migration files:

```kotlin
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL(
            "ALTER TABLE posts ADD COLUMN edited_at INTEGER DEFAULT 0"
        )
    }
}

// Apply in database builder
Room.databaseBuilder(context, AppDatabase::class.java, "snoozespot.db")
    .addMigrations(MIGRATION_1_2)
    .build()
```

---

## Development Guidelines

### Code Style & Conventions

#### Kotlin Naming Conventions

```kotlin
// Classes: PascalCase
class SpotViewModel { }

// Functions & properties: camelCase
fun fetchSpots() { }
val spotCount = 0

// Constants: CONSTANT_CASE (or val in objects)
object Constants {
    const val MAX_RETRIES = 3
    const val API_TIMEOUT = 30L
}

// Enum and sealed classes: PascalCase
enum class SortOption {
    NAME_ASC,
    RATING_DESC,
    DISTANCE
}

sealed class ApiResult<T> {
    data class Success<T>(val data: T) : ApiResult<T>()
    data class Error<T>(val message: String) : ApiResult<T>()
}
```

#### Compose Function Conventions

```kotlin
// File organization: one main function per file or related functions grouped

// Composable function naming: noun or adjective describing UI
@Composable
fun SpotCard(spot: Spot, onSpotClick: (Spot) -> Unit) {
    // Implementation
}

// Internal/preview functions: prefix with underscore or @Preview annotation
@Preview
@Composable
private fun SpotCardPreview() {
    SpotCard(
        spot = Spot.MOCK_DATA,
        onSpotClick = {}
    )
}

// State management
@Composable
fun SpotListScreen(viewModel: SpotListViewModel = viewModel()) {
    val spots by viewModel.spots.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    
    // UI composition
}
```

### Repository Pattern Implementation

```kotlin
// High-level business logic
class SpotRepository(
    private val apiService: SpotApiService,
    private val spotDao: SpotDao,
    private val context: Context
) {
    // Return Flow for reactive data
    fun getSpots(): Flow<Result<List<Spot>>> = flow {
        emit(Result.Loading)
        try {
            // Try network first
            val apiSpots = apiService.getSpots()
            spotDao.insertSpots(apiSpots.map { it.toEntity() })
            emit(Result.Success(apiSpots.map { it.toDomain() }))
        } catch (e: Exception) {
            // Fall back to cache
            val cachedSpots = spotDao.getAllSpots().firstOrNull() ?: emptyList()
            if (cachedSpots.isNotEmpty()) {
                emit(Result.Success(cachedSpots.map { it.toDomain() }))
            } else {
                emit(Result.Error(e))
            }
        }
    }

    // Single operation
    suspend fun createPost(post: Post): Result<Post> = withContext(Dispatchers.IO) {
        return@withContext try {
            val created = apiService.createPost(post.toDTO())
            postDao.insertPost(created.toEntity())
            Result.Success(created.toDomain())
        } catch (e: Exception) {
            Result.Error(e)
        }
    }
}

sealed class Result<T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error<T>(val exception: Exception) : Result<T>()
    class Loading<T> : Result<T>()
}
```

### Error Handling

```kotlin
// Custom exception types
sealed class SnoozeSpotException : Exception() {
    data class NetworkException(val statusCode: Int, message: String) : SnoozeSpotException()
    data class DataValidationException(val field: String, message: String) : SnoozeSpotException()
    data class AuthenticationException(message: String) : SnoozeSpotException()
}

// Error handling in ViewModel
class SpotListViewModel(private val repository: SpotRepository) : ViewModel() {
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()

    fun loadSpots() {
        viewModelScope.launch {
            repository.getSpots()
                .catch { e ->
                    _error.value = when (e) {
                        is SnoozeSpotException.NetworkException -> "Network error: ${e.statusCode}"
                        is SnoozeSpotException.AuthenticationException -> "Please log in again"
                        else -> "An error occurred"
                    }
                }
                .collect { spots -> /* update UI */ }
        }
    }

    fun clearError() {
        _error.value = null
    }
}
```

### Logging

```kotlin
// Simple logging utility
object Logger {
    fun d(tag: String, message: String) {
        if (BuildConfig.DEBUG) {
            Log.d(tag, message)
        }
    }

    fun e(tag: String, message: String, throwable: Throwable? = null) {
        Log.e(tag, message, throwable)
    }
}

// Usage
Logger.d("SpotRepository", "Fetching spots from network")
Logger.e("SpotRepository", "Failed to fetch spots", exception)
```

### Testing Best Practices

```kotlin
// Unit test example
class SpotRepositoryTest {
    private lateinit var repository: SpotRepository
    private val mockApiService = mockk<SpotApiService>()
    private val mockDao = mockk<SpotDao>()

    @Before
    fun setup() {
        repository = SpotRepository(mockApiService, mockDao)
    }

    @Test
    fun testGetSpotsFallsBackToCache() = runTest {
        // Mock API failure
        coEvery { mockApiService.getSpots() } throws IOException()
        
        // Mock cached data
        coEvery { mockDao.getAllSpots() } returns flowOf(listOf(mockEntity))

        // Assert
        repository.getSpots().test {
            assertTrue(awaitItem() is Result.Success)
        }
    }
}

// UI test example
class SpotListScreenTest {
    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun testSpotCardDisplaysCorrectly() {
        val spot = Spot.MOCK_DATA
        composeTestRule.setContent {
            SpotCard(spot, {})
        }

        composeTestRule.onNodeWithText(spot.name).assertIsDisplayed()
    }
}
```

### Dependency Injection

While SnoozeSpot doesn't use a formal DI framework currently, consider these patterns:

```kotlin
// Manual injection in Application class
class SnoozeSpotApp : Application() {
    private val database by lazy { AppDatabase.getInstance(this) }
    private val repository by lazy { SpotRepository(apiService, database.spotDao()) }

    fun getRepository(): SpotRepository = repository
}

// Or use Hilt for automatic dependency injection (recommended for larger projects)
// Add dependency: implementation("com.google.dagger:hilt-android:latest")

@HiltViewModel
class SpotListViewModel @Inject constructor(
    private val repository: SpotRepository
) : ViewModel() {
    // ViewModel implementation
}
```

---

## Contributing Guidelines

### Contribution Workflow

1. **Fork the Repository**
   ```bash
   # Clone your fork
   git clone https://github.com/your-username/SnoozeSpot.git
   cd SnoozeSpot
   ```

2. **Create a Feature Branch**
   ```bash
   # Use descriptive branch names
   git checkout -b feature/add-favorites-list
   git checkout -b bugfix/fix-map-crashes
   git checkout -b chore/update-dependencies
   ```

3. **Make Changes**
   - Follow code style guidelines (see Development Guidelines section)
   - Write clean, well-commented code
   - Add unit tests for new functionality
   - Update documentation as needed

4. **Commit Your Changes**
   ```bash
   # Follow commit message format
   git commit -m "feat: add favorites list to home screen

   - Display user's favorite spots in dedicated section
   - Add swipe-to-remove gesture
   - Persist favorites in Room database
   
   Closes #123"
   ```

### Commit Message Format

Follow conventional commits:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
**Scope**: `api`, `ui`, `database`, `auth`, `maps`, etc.
**Subject**: Imperative mood, no period, max 50 chars
**Body**: Explain what and why, not how
**Footer**: Reference issues: `Closes #123`, `Fixes #456`

### Code Review Expectations

- All PRs require at least 1 approval before merging
- Address review comments before re-requesting review
- Run tests locally before submitting
- Keep commits organized and logically grouped
- Update branch if conflicts arise with main

### Testing Requirements

- Add unit tests for new business logic
- Add UI tests for new screens/components
- Ensure existing tests pass: `./gradlew test`
- Run code quality checks: `./gradlew lint`

### Documentation Updates

- Update relevant sections in `doc.md` for significant changes
- Add Javadoc comments for public API
- Update README if user-facing features change
- Add code examples for complex implementations

---

## Troubleshooting

### Common Issues & Solutions

#### 1. Gradle Sync Failures

**Problem**: "Could not download artifact" or "Repository not found"

**Solution**:
```bash
# Clear Gradle cache
./gradlew clean

# Update dependencies
./gradlew dependencies --refresh-dependencies

# Sync project in Android Studio: File → Sync Now
```

#### 2. OpenAPI Generator Errors

**Problem**: "OpenAPI spec file not found" or "Generator failed"

**Solution**:
- Verify OpenAPI spec file path in `build.gradle.kts`
- Check spec file format (must be valid YAML/JSON)
- Regenerate: `./gradlew generateOpenApiClient --rerun-tasks`
- Check output in `app/build/generated/openapi/`

#### 3. Google Maps API Errors

**Problem**: "MapsInitializationException" or blank map

**Solution**:
```properties
# Verify MAPS_API_KEY in secrets.properties
MAPS_API_KEY=your_valid_key_here

# Ensure API is enabled in Google Cloud Console:
# 1. Go to Google Cloud Console
# 2. Enable "Maps SDK for Android"
# 3. Generate/copy API key
# 4. Add app's SHA-1 fingerprint to key restrictions

# Debug with logcat
adb logcat | grep "MapsInitializationException"
```

#### 4. Certificate/SSL Errors

**Problem**: "CERTIFICATE_VERIFY_FAILED" when calling API

**Solution**:
```kotlin
// For development only - add to OkHttpClient builder:
val builder = OkHttpClient.Builder()
if (BuildConfig.DEBUG) {
    // Only for dev/testing with self-signed certificates
    builder.hostnameVerifier { _, _ -> true }
}

// For production: ensure server has valid SSL certificate
```

#### 5. Database Migration Errors

**Problem**: "Room cannot verify the data integrity" or migration crash

**Solution**:
```kotlin
// Uninstall app to clear database during development
adb uninstall iut.fauryollivier.snoozespot.dev

// Or use fallback strategy in AppDatabase:
Room.databaseBuilder(context, AppDatabase::class.java, "snoozespot.db")
    .fallbackToDestructiveMigration()  // Only for dev!
    .build()

// For production: create proper migration files
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        // Migration SQL
    }
}
```

#### 6. Build Variant Not Changing

**Problem**: App still uses old flavor after changing variant

**Solution**:
```bash
# Clean build completely
./gradlew clean

# Rebuild
./gradlew assembleProductionDebug

# In Android Studio:
# - Go to Build → Clean Project
# - Go to View → Tool Windows → Build Variants
# - Select desired variant
# - Sync Gradle
```

#### 7. Network Timeouts

**Problem**: API calls timeout frequently

**Solution**:
```kotlin
// Increase timeout in OkHttpClient
val httpClient = OkHttpClient.Builder()
    .connectTimeout(60, TimeUnit.SECONDS)  // Increase from 30
    .readTimeout(60, TimeUnit.SECONDS)
    .writeTimeout(60, TimeUnit.SECONDS)
    .build()

// Check network connectivity
// Consider implementing exponential backoff for retries
```

#### 8. Compose Layout Issues

**Problem**: UI elements not rendering correctly

**Solution**:
- Check preview annotations: `@Preview`
- Use `debugInspectorInfo()` for layout debugging
- Verify state updates in `LaunchedEffect`
- Check for recomposition loops (side effects in composables)
- Use `remember` for state preservation

#### 9. Room Query Errors

**Problem**: "androidx.room.RoomSQLiteQuery: (SQLiteException)"

**Solution**:
```kotlin
// Verify SQL syntax in @Query annotations
// Common mistakes:
@Query("SELECT * FROM spots WHERE name LIKE :query")  // Correct
@Query("SELECT * FROM spots WHERE name LIKE %:query%") // Wrong - use binding

// Use database inspector: Device File Explorer → data/data/[app_id]/databases/
```

#### 10. Memory Leaks

**Problem**: App crashes with "OutOfMemoryError"

**Solution**:
- Check image loading (use Coil for caching)
- Verify coroutine scope cleanup
- Use Android Profiler to detect leaks:
  - Run → Profile [app name]
  - Memory tab → Heap Dump → Analyze

---

## Additional Resources

### Official Documentation
- [Android Developers](https://developer.android.com/)
- [Jetpack Compose](https://developer.android.com/jetpack/compose)
- [Room Database](https://developer.android.com/training/data-storage/room)
- [Retrofit](https://square.github.io/retrofit/)
- [Google Maps Platform](https://developers.google.com/maps)

### Libraries & Tools
- [Gradle Build Tool](https://gradle.org/)
- [OkHttp](https://square.github.io/okhttp/)
- [Kotlin Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)
- [OpenAPI Generator](https://openapi-generator.tech/)

### Getting Help
- Check existing GitHub issues
- Review Android official documentation
- Check Stack Overflow with tags: `android`, `kotlin`, `jetpack-compose`

---

## Changelog

### Version 1.0 (Current)
- Initial release
- Core features: Spot discovery, mapping, posts, comments
- Multi-flavor build support
- Google Maps integration
- Room database persistence
- Jetpack Compose UI

---

**Last Updated**: January 13, 2026
**Maintained By**: SnoozeSpot Development Team

